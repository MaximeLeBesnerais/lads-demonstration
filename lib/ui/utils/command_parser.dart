/// Represents a parsed command with a user-friendly action name and details.
class ParsedCommand {
  final String rawCommand;
  final String action;
  final Map<String, String> details;
  final bool isSupported; // Flag if the parser recognizes the command

  ParsedCommand({
    required this.rawCommand,
    required this.action,
    required this.details,
    this.isSupported = true,
  });

  @override
  String toString() {
    if (!isSupported) {
      return 'Unsupported Command: $rawCommand';
    }
    String detailsString = details.entries.map((e) => '${e.key}: ${e.value}').join(', ');
    return 'Action: $action ($detailsString)';
  }
}

/// Parses raw command strings generated by the AI into a structured,
/// human-readable format.
class CommandParser {
  static ParsedCommand parse(String commandLine) {
    final parts = commandLine.trim().split(' ');
    if (parts.isEmpty || parts[0].isEmpty) {
      return ParsedCommand(rawCommand: commandLine, action: 'Error', details: {'Message': 'Empty command'}, isSupported: false);
    }

    final command = parts[0].toLowerCase();
    final args = parts.length > 1 ? parts.sublist(1) : <String>[];

    try {
      switch (command) {
        case 'add_node':
          if (args.length < 2) throw const FormatException('Insufficient arguments');
          return ParsedCommand(
            rawCommand: commandLine,
            action: 'Add Node',
            details: {
              'Name': args[0],
              'Cores': args[1],
              if (args.length > 2) 'Class': args[2],
            },
          );

        case 'add_task':
           if (args.length < 3) throw const FormatException('Insufficient arguments');
           return ParsedCommand(
             rawCommand: commandLine,
             action: 'Add Task',
             details: {
               'Name': args[0],
               'Duration (s)': args[1],
               'Cores': args[2],
               if (args.length > 3) 'Class': args[3],
             },
           );

        case 'list':
        case 'ls':
          return ParsedCommand(rawCommand: commandLine, action: 'List Nodes', details: {});

        case 'queue':
          return ParsedCommand(rawCommand: commandLine, action: 'List Task Queue', details: {});

        case 'process':
          return ParsedCommand(rawCommand: commandLine, action: 'Process Task Queue', details: {});

        case 'status':
          if (args.isEmpty) throw const FormatException('Missing node identifier');
          return ParsedCommand(rawCommand: commandLine, action: 'Get Node Status', details: {'Node ID/Name': args[0]});

        case 'active':
        case 'inactive':
        case 'maintain':
        case 'decom':
           if (args.isEmpty) throw const FormatException('Missing node identifier');
           String actionName = command[0].toUpperCase() + command.substring(1); // Capitalize
           return ParsedCommand(rawCommand: commandLine, action: 'Set Node $actionName', details: {'Node ID': args[0]});

        case 'remove':
           if (args.isEmpty) throw const FormatException('Missing node identifier');
           return ParsedCommand(
              rawCommand: commandLine,
              action: 'Remove Node',
              details: {
                 'Node ID': args[0],
                 if (args.length > 1 && args[1].toLowerCase() == 'force') 'Mode': 'Force',
              }
           );

        case 'repurpose':
           if (args.length < 2) throw const FormatException('Insufficient arguments');
           return ParsedCommand(
              rawCommand: commandLine,
              action: 'Repurpose Node',
              details: {'Node ID': args[0], 'New Class': args[1]}
           );

        case 'logs':
           return ParsedCommand(rawCommand: commandLine, action: 'Show Logs', details: {});

        case 'clearlogs':
           return ParsedCommand(rawCommand: commandLine, action: 'Clear Logs', details: {});

        // Add other commands the AI might generate (help, set_api_key unlikely)

        default:
          return ParsedCommand(rawCommand: commandLine, action: 'Unknown', details: {'Command': command}, isSupported: false);
      }
    } catch (e) {
       return ParsedCommand(rawCommand: commandLine, action: 'Error Parsing', details: {'Message': e.toString()}, isSupported: false);
    }
  }
}
